<html>

<head>
    <title>Race Game</title>
    <style>
        #game {
            display: flex;
            justify-content: center;
        }

        #toolbox {
            width: 30px;
            height: 30px;
            background-color: red;
            cursor: grab;
        }

        #view {
            border: 1px solid black;
        }
    </style>
</head>

<body>
    <ul>
        {% for map_id, map_info in map_and_views.items %}
        <li>Map {{ map_id }}: {{ map_info.0 }} <button>Draw</button></li>
        <ul>
            {% for view_id, view_description in map_info.1.items %}
            <li>View {{ view_id }}: {{ view_description }} <button>Draw</button></li>
            {% endfor %}
        </ul>
        {% endfor %}
    </ul>

    <div id="game">
        <div id="toolbox" draggable="true"></div>
        <div id="view"></div>
    </div>

    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script>
        const width = 500;
        const height = 500;
        const cellSize = 30;

        const stage = new Konva.Stage({
            container: "view",
            width: 500,
            height: 500,
        });

        const gridLayer = new Konva.Layer();
        const padding = cellSize;
        for (var i = 0; i < width / padding; i++) {
            gridLayer.add(new Konva.Line({
                points: [Math.round(i * padding) + 0.5, 0, Math.round(i * padding) + 0.5, height],
                stroke: '#ddd',
                strokeWidth: 1,
            }));
        }
        gridLayer.add(new Konva.Line({ points: [0, 0, 10, 10] }));
        for (var j = 0; j < height / padding; j++) {
            gridLayer.add(new Konva.Line({
                points: [0, Math.round(j * padding), width, Math.round(j * padding)],
                stroke: '#ddd',
                strokeWidth: 0.5,
            }));
        }
        stage.add(gridLayer);

        const tileLayer = new Konva.Layer();
        const shadow = new Konva.Rect({
            width: cellSize,
            height: cellSize,
            fill: '#808080',
            opacity: 0.5,
            stroke: '#404040',
            strokeWidth: 3
        });
        shadow.hide();
        tileLayer.add(shadow);
        stage.add(tileLayer);

        function newRectangle(x, y) {
            let rectangle = new Konva.Rect({
                x: Math.round(x / cellSize) * cellSize,
                y: Math.round(y / cellSize) * cellSize,
                width: cellSize,
                height: cellSize,
                fill: '#000',
                stroke: '#ddd',
                strokeWidth: 1,
                draggable: true
            });
            rectangle.on('dragstart', (e) => {
                shadow.show();
                shadow.moveToTop();
                rectangle.moveToTop();
            });
            rectangle.on('dragend', (e) => {
                rectangle.position({
                    x: Math.round(rectangle.x() / cellSize) * cellSize,
                    y: Math.round(rectangle.y() / cellSize) * cellSize
                });
                stage.batchDraw();
                shadow.hide();
            });
            rectangle.on('dragmove', (e) => {
                shadow.position({
                    x: Math.round(rectangle.x() / cellSize) * cellSize,
                    y: Math.round(rectangle.y() / cellSize) * cellSize
                });
                stage.batchDraw();
            });
            tileLayer.add(rectangle);
        }

        // Handle drag events
        document
            .getElementById("toolbox")
            .addEventListener("dragstart", function (e) {
                e.dataTransfer.setData("text/plain", "dragging");
            });

        stage.container().addEventListener("dragover", function (e) {
            e.preventDefault(); // Necessary for the drop event to work
        });

        stage.container().addEventListener("drop", function (e) {
            e.preventDefault();
            stage.setPointersPositions(e);
            const pos = stage.getPointerPosition();
            newRectangle(pos.x - cellSize / 2, pos.y - cellSize / 2);
        });
    </script>
</body>

</html>